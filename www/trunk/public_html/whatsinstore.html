<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>phc -- the open source PHP compiler</title>
		<link rel="stylesheet" type="text/css" href="phc.css">
	</head>
	<body>
		<table width=796" align="center" cellspacing="0" cellpadding="2" style="border: #8a7640 solid 1px;">
		<tr>
			<td height="149" style="background: url(img/header.png);">&nbsp;</td>
		</tr>
		<tr>
			<td style="color: white; background-color: #8a7640;">
				<a class="nav" href="index.html">Home</a> | 
				<a class="nav" href="src/index.html">Downloads</a> | 
				<a class="nav" href="doc/index.html">Documentation</a> |
				<a class="nav" href="plugins/index.html">Plugins</a> |
				<a class="nav" href="spinoffs/index.html">Spinoff Projects</a> |
				<a class="nav" href="contact.html">Mailing List</a>
			</td>
		</tr>
		<tr><td style="padding: 5px;">
			<h1>What's in Store?</h1>

			<p> Below are some of the features we are planning to add to <span
			class="phc">phc</span>, approximately in the order we'd like to
			implement them. Version 0.1.7 saw the last major improvement of the
			tree transformation and tree visitor APIs; the focus is now on
			generating code (see first section, below). </p>

			<h2>Generating Code</h2>

			<p> Using the AST, we are trying to compile PHP scripts to C, and link
			them with PHP using the PHP <i>embed</i> SAPI. Though in the future
			we intend to generate native code, C allows us to quickly prototype
			this feature, and does so in a platform independent manner.  After C,
			we will generate Intel x86 code for Linux, although it should not be
			too difficult to add support for other systems, too (esp. similar
			systems such as FreeBSD). </p>


			<h2>Compile Extensions</h2>

			<p> We are planning to make <span class="phc">phc</span> generate PHP
			extensions that can be loaded into the PHP interpreter. This means
			that you can write PHP extensions <i>in PHP</i> and use <span
			class="phc">phc</span> to compile them. This will be very useful for
			people that write extensions for the purpose of speed or protecting
			proprietary code. </p>

			<h2>Better Refactoring Support</h2>

			<p> Although <span class="phc">phc</span> can dump its internal
			representation back to PHP with the <i>--pretty-print</i> flag, this
			output does not greatly resemble the original code. This makes <span
			class="phc">phc</span> difficult to use for <a
			href=spinoffs/index.html#refactoring>refactoring tools</a> in which
			the programmer wishes to see the output. A better solution is that
			after a user's code has been transformed internally, <span
			class="phc">phc</span>'s output would be identical to the original
			code. Newly generated or altered code would be formateed in a manner
			consistent with the rest of the code, or the code it replaced. </p>


			<h2>Intermediate Representation (IR)</h2>

			<p> While our current attempt to compile PHP uses C, our experience
			with this will help us define a low-level intermediate representation,
			into which we will initially translate PHP. This representation looks
			like machine language (or Java bytecode), but is actually machine
			independent. The purpose of the IR is to define a very simple language
			with as few constructs as possible, that exposes most of the details
			that are implicit in PHP scripts, and over which we can define all
			sorts of compiler optimizations. </p>

			<p> To give you an idea, an if-statement such as </p>

<pre>
<b>if</b>($c == 1)
  $d = $c * 2 + 1;
</pre>

 			<p> might look like </p>

<pre>
   $r := $c.equals 1
   $r := $r.not
   <b>if</b> $r <b>goto</b> l1
   $t := $c.mult 2
   $d := ^$t.add 1
l1:
</pre>

			<p> in the intermediate representation. We are currently investigating
			what the IR should look like, and our experience with generating C
			will colour this appropriately. </p>

			<h2>Static Analyses and Code Optimization</h2>
			
			<p> Once all that is done, we can start the really interesting work:
			optimizing scripts. Many of these optimizations require analyses that
			are defined over the IR. It is our intention to make the results of
			these analyses available at the AST level as well, so that it is
			possible to define transformations that operate on PHP source (e.g.,
			refactoring), but make use of analyses defined on the IR. Here are a
			couple of optimizations we are planning to implement: </p>

			<h3>Static Single Assignment (SSA) Form</h3>
			
			<p> SSA is a transformation on the IR that guarantees that every
			variable only gets assigned in one location in the program. This is a
			very useful optimization, because it makes many other optimizations
			much easier to define. Consider the following PHP script </p>

<pre>
&lt;?<b>php</b>
   $x = foo();
   <b>echo</b> $x;

   $x = $x + bar();
   <b>echo</b> $x;
?&gt;
</pre>

			<p> Gets translated into </p>

<pre>
&lt;?<b>php</b>
   $x0 = foo();
   <b>echo</b> $x0;

   $x1 = $x0 + bar();
   <b>echo</b> $x1;
?&gt;
</pre>

			<p> This makes the relation between the assignments to variables and
			the use of variables more obvious. This is useful for a number of
			things. For example, consider a refactoring to make sure that the
			result of <code>dbx_connect</code> always get stored in a variable
			called <code>dbx_link</code>. Then, the following code </p>

<pre>
&lt;?<b>php</b>
   $x = dbx_connect(...);
   some_function($x);
   
   $x = some_other_function();
   some_function($x);
?&gt;
</pre>

			<p> should get translated to </p>

<pre>
&lt;?<b>php</b>
   $dbx_link = dbx_connect(...);
   some_function($dbx_link);
   
   $x = some_other_function();
   some_function($x);
?&gt;
</pre>

			<p> In particular, the second <code>some_function($x)</code> should
			not be modified. Converting the program to SSA form first will make
			this easier. </p>

			<h3> Type Inference </h3>

			<p> Type inference tries to find out the type of each variable. We
			will do type inference on the SSA form of the program. This means that
			every variable can only have a single type (because it is only
			assigned once). Apart from compilation, type inference is useful for
			numerous other tasks. As a simple example, consider implementing a
			<a href="spinoffs/index.html#semantic">semantic checker</a>. For
			example, in the following code, </p>

<pre>
$x = $x + $y;
</pre>
			
			<p> if we can deduce that both <code>$x</code> and <code>$y</code>
			have type <code>string</code>, we might issue a warning that the plus
			(<code>+</code>) should probably be a dot (<code>.</code>) (PHP will
			warn for this at run-time if <code>error_reporting</code> is set high
			enough, but it is useful to catch these errors at compile time.) </p>

			<p> For a more complicated example, consider renaming a class method.
			If we rename method <code>foo</code> to <code>bar</code> in class
			<i>A</i> (but not in class <i>B</i>) in the following example, </p>
			
<pre>
&lt;?<b>php</b>
   <b>class</b> A
   {
      <b>function</b> foo 
      { 
         <b>echo</b> "Hello "; 
      }
   }

   <b>class</b> B
   {
      <b>function</b> foo 
      { 
         <b>echo</b> "world!"; 
      }
   }

   $a = <b>new</b> A();
   $b = <b>new</b> B();

   $a-&gt;foo();
   $b-&gt;foo();
?&gt;
</pre>

			<p> we should get </p>

<pre>
&lt;?<b>php</b>
   <b>class</b> A
   {
      <b>function</b> <span class="box">bar</span> 
      { 
         <b>echo</b> "Hello "; 
      }
   }

   <b>class</b> B
   {
      <b>function</b> foo 
      { 
         <b>echo</b> "world!"; 
      }
   }

   $a = <b>new</b> A();
   $b = <b>new</b> B();

   $a-&gt;<span class="box">bar()</span>;
   $b-&gt;foo();
?&gt;
</pre>

			<p> In particular, the line <code>$b-&gt;foo();</code> should not be
			modified. We can only do this if we know that the type of
			<code>$a</code> is A, and the type of <code>$b</code> is B. Type
			inference cannot always be 100% accurate; in such a case, refactoring
			should fail (or insert code to explicitly distinguish between a few
			types). </p>

			<p> So stay tuned :-) </p>

		</td></tr>
		<tr>
			<td style="border-top: solid #8a7640 1px; font-size: 8pt; background-color: #efdca5;">
				$LastChangedDate: 2007-01-17 15:55:22 +0000 (Wed, 17 Jan 2007) $. Contents &copy; the <a href="authors.html">authors</a>.
			</td>
		</tr>
		</table>
	</body>
</html>
