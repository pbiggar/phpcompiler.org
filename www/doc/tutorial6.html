<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>phc -- Tutorial 6: Returning Lists</title>
		<link rel="stylesheet" type="text/css" href="../phc.css">
	</head>
	<body>
		<table width="796" align="center" cellspacing="0" cellpadding="2" style="border: #8a7640 solid 1px;">
		<tr>
			<td height="149" style="background: url(../img/header.png);">&nbsp;</td>
		</tr>
		<tr>
			<td style="color: white; background-color: #8a7640;">
				<a class="nav" href="../index.html">Home</a> | 
				<a class="nav" href="../src/index.html">Downloads</a> | 
				<a class="nav" href="../doc/index.html">Documentation</a> |
				<a class="nav" href="../plugins/index.html">Plugins</a> |
				<a class="nav" href="../spinoffs/index.html">Spinoff Projects</a> |
				<a class="nav" href="../contact.html">Mailing List</a>
			</td>
		</tr>
		<tr><td style="padding: 5px;">
			<h1>Tutorial 6: Returning Lists</h1>

			In this tutorial we will develop step-by-step a transform that expands <code>include</code> statements. For example, if <tt>b.php</tt> is

<pre>
&lt;?<b>php</b>
   echo "Hello world";
?&gt;
</pre>
			
			<p>and <tt>a.php</tt> is</p> 

<pre>
&lt;?<b>php</b>
   include "b.php";
   echo "Goodbye!";
?&gt;
</pre>
			<p>Then running the transform on <tt>a.php</tt> yields </p>

<pre>
&lt;?<b>php</b>
   echo "Hello world\n";
   echo "Goodbye\n";
?&gt;
</pre>

			<p> The transform we will develop in this tutorial is only a simple
			implementation of <code>include</code>s; a more full-featured
			transform is available using the option
			<code>--compile-time-includes</code>. The code for that transform
			is <tt>process_ast/Process_includes.cpp</tt>. The transform we will
			develop here is available as
			<tt>plugins/tutorials/Expand_includes.so</tt>. </p>

			<h2> Deleting Nodes </h2>

			<p> Our transform should process <code>include</code> statements.
			In the AST, <code>include</code>s are represented as method
			invocations. Thus, we might start like this: </p>

<pre>
<b>class</b> Expand_includes : <b>public</b> Tree_transform
{
<b>public</b>:
   AST_expr* pre_method_invocation(AST_method_invocation* in)
   {
      <i>// Process includes</i>
   }
};
</pre>

			<p> However, this will not get us very far. The return type of
			<code>pre_method_invocation</code> is an <code>AST_expr</code>.
			That means that we can replace the method invocation (the
			<code>include</code> statement) only by another, single,
			expression. But we want to replace it by the contents of the
			specified file! </p>

			<p> Recall from <a href="tutorial1.html">Tutorial 1</a> that to
			turn an expression into a statement, <span class="phc">phc</span>
			inserts an <code>AST_eval_expr</code> in the abstract syntax tree.
			Thus, if we want to process <code>include</code> statements, we
			could also look at all <code>eval_expr</code> nodes. Assuming for
			the moment we can make that work, does it get us any further? As a
			matter of fact, it does! If you check
			<tt>&lt;phc/Tree_transform.h&gt;</tt>, you will see that the 
			signature for <code>pre_eval_expr</code> is </p>

<pre>
<b>void</b> pre_eval_expr(AST_eval_expr* in, AST_statement_list* out)
</pre>

			<p> This is different from the signatures we have seen so far. For
			nodes that can be replaced by a number of new nodes, the pre transform
			and post transform methods will not have a return value in their
			signature, but have an extra <code>AST_xxx_list</code> argument.
			This list is initialised to be empty before
			<code>pre_eval_expr</code> is invoked, and when
			<code>pre_eval_expr</code> returns, the nodes in this list will
			replace <code>*in</code>. If the list is empty, the node is simply
			deleted from the tree. </p>

			<p> So, we will use the following plugin as our starting point.
			Executing this plugin deletes all <code>eval_expr</code> nodes from
			the tree (try it!). </p>

<pre>
<b>#include</b> &lt;phc/Tree_transform.h&gt;

<b>class</b> Expand_includes : <b>public</b> Tree_transform
{
<b>public</b>:
   <b>void</b> pre_eval_expr(AST_eval_expr* in, AST_statement_list* out)
   {
   }
};

<b>extern</b> "C" <b>void</b> process_ast(AST_php_script* php_script)
{
   Expand_includes einc;
   php_script-&gt;transform(&amp;einc);
}
</pre>

			<h2> Using the XML unparser </h2>

			<p> So, we now want to do something more useful than deleting all
			<code>eval_expr</code> nodes from the tree. The first thing we need
			to be able to do is distinguish <code>include</code> statements
			from other <code>eval_expr</code> nodes. We can use pattern
			matching (see tutorials <a href="tutorial3.html">3</a> and <a
			href="tutorial4.html">4</a>) to do that - but what should we match
			against? If you are unsure about the structure of the tree, it can
			be quite useful to use the XML unparser to find out what the tree
			looks like. We modify the plugin as follows: </p>

<pre>
<b>#include</b> &lt;phc/Tree_transform.h&gt;
<b>#include</b> &lt;phc/process_ast/XML_unparser.h&gt;

<b>class</b> Expand_includes : <b>public</b> Tree_transform
{
<b>private</b>:
   XML_unparser xml_unparser;

<b>public</b>:
   void pre_eval_expr(AST_eval_expr* in, AST_statement_list* out)
   {
      in-&gt;visit(&amp;xml_unparser);
   }
}
</pre>

			<p> The XML unparser is implemented using the
			<code>Tree_visitor</code> API, so it can be invoked just like you
			run any other visitor. There is a similar visitor called
			<code>PHP_unparser</code> (in
			<tt>&lt;phc/process_ast/PHP_unparser.h&gt;</tt>) that you can use
			to print (parts of the) AST to PHP syntax. </p>

			<p> When you run this transform on <tt>a.php</tt>, it will print
			two <code>eval_expr</code> nodes (shown in XML syntax), one for the
			<code>include</code> and one for the <code>echo</code> . We are
			interested in the first, the <code>include</code>: (we have removed
			the <code>&lt;attrs /&gt;</code> blocks to improve readability):
			</p>

<pre>
&lt;AST_eval_expr&gt;
   &lt;AST_method_invocation&gt;
      &lt;Token_class_name&gt;
         &lt;value&gt;%STDLIB%&lt;/value&gt;
      &lt;/Token_class_name&gt;
      &lt;Token_method_name&gt;
         &lt;value&gt;include&lt;/value&gt;
      &lt;/Token_method_name&gt;
      &lt;AST_actual_parameter_list&gt;
         &lt;AST_actual_parameter&gt;
            &lt;bool&gt;false&lt;/bool&gt;
            &lt;Token_string&gt;
               &lt;value&gt;b.php&lt;/value&gt;
               &lt;source_rep&gt;b.php&lt;/source_rep&gt;
            &lt;/Token_string&gt;
         &lt;/AST_actual_parameter&gt;
      &lt;/AST_actual_parameter_list&gt;
   &lt;/AST_method_invocation&gt;
&lt;/AST_eval_expr&gt;
</pre>

			<p> This tells us that the <code>include</code> statement is an
			<code>eval_expr</code> node (that was obvious from the fact that we
			implemented <code>pre_eval_expr</code>). The <code>eval_expr</code>
			contains a <code>method_invocation</code> (we knew that too). The
			method invocation has target <code>%STDLIB%</code>, method name
			<code>include</code>, and a single parameter in the parameter list
			that contains the name of the file we are interested in. We can
			construct a pattern that matches this tree exactly: </p>

<pre>
<b>class</b> Expand_includes : <b>public</b> Tree_transform
{
<b>public</b>:
   <b>void</b> pre_eval_expr(AST_eval_expr* in, AST_statement_list* out)
   {
      <i>// Pattern to match include statements</i>   
      Token_string* filename; 
      AST_actual_parameter* param;
      AST_actual_parameter_list* params;
      Token_method_name* method_name;
      Token_class_name* target; 
      AST_method_invocation* pattern;
      
      filename = <b>new</b> Token_string(WILDCARD, WILDCARD);
      param = <b>new</b> AST_actual_parameter(false, filename);
      params = <b>new</b> AST_actual_parameter_list();
      params-&gt;push_back(param);
      method_name = <b>new</b> Token_method_name(<b>new</b> String("include"));
      target = <b>new</b> Token_class_name(<b>new</b> String("%STDLIB%"));
      pattern = <b>new</b> AST_method_invocation(target, method_name, params);

      <i>// Check we have a matching function</i>
      <b>if</b>(!in-&gt;expr-&gt;match(pattern))
      {
         <i>// No match; leave untouched</i>
         out-&gt;push_back(in);
      }
      <b>else</b>
      {
         <i>// Process the include</i>
      }
   }
};
</pre>
	
			<p> Note how the construction of the pattern follows the structure
			of the tree as output by the XML unparser exactly. The only
			difference is that we leave the actual filename a wildcard;
			obviously, we want to be able to match against any
			<code>include</code>, not just <code>include("a.php")</code>.
			Running this transform should remove the <code>include</code> from
			the file, but leave the other statements untouched (note that we
			need to <code>push_back in</code> to <code>out</code> to make sure
			a statement does not get deleted). </p>

			<h2> The Full Transform </h2>

			<p> Remember from the previous tutorials that code defined outside
			the scope of any class and any function becomes part of
			<code>%MAIN%::%run%</code> in <span class="phc">phc</span>'s
			internal representation. So, to expand the include, we need to
			parse the specified file, and replace the <code>include</code> by
			all the statements in <code>%MAIN%::%run%</code> in the parsed
			script (we should also deal with the other functions of
			<code>%MAIN%</code>, and with any other classes or interfaces in
			the included script; this is left as an exercise for the reader).
			Here then is the full transform: </p>  

<pre>
<b>#include</b> &lt;phc/Tree_transform.h&gt;
<b>#include</b> &lt;phc/parse.h&gt;

<b>class</b> Expand_includes : <b>public</b> Tree_transform
{
<b>public</b>:
   <b>void</b> pre_eval_expr(AST_eval_expr* in, AST_statement_list* out)
   {
      <i>// Pattern to match include statements</i> 
      Token_string* filename; 
      AST_actual_parameter* param;
      AST_actual_parameter_list* params;
      Token_method_name* method_name;
      Token_class_name* target; 
      AST_method_invocation* pattern;
      
      filename = <b>new</b> Token_string(WILDCARD, WILDCARD);
      param = <b>new</b> AST_actual_parameter(false, filename);
      params = <b>new</b> AST_actual_parameter_list();
      params-&gt;push_back(param);
      method_name = <b>new</b> Token_method_name(<b>new</b> String("include"));
      target = <b>new</b> Token_class_name(<b>new</b> String("%STDLIB%"));
      pattern = <b>new</b> AST_method_invocation(target, method_name, params);

      <i>// Check we have a matching function</i>
      <b>if</b>(!in-&gt;expr-&gt;match(pattern))
      {
         <i>// No match; leave untouched</i>
         out-&gt;push_back(in);
      }
      <b>else</b>
      {
         <i>// Try to open the file</i>
         AST_php_script* php_script = parse(filename-&gt;value, <b>NULL</b>, <b>false</b>); 
         <b>if</b>(php_script == <b>NULL</b>)
         {
            cout &lt;&lt; "Could not parse file " &lt;&lt; *filename-&gt;value;
            cout &lt;&lt; " on line " &lt;&lt; in-&gt;get_line_number() &lt;&lt; endl;
            exit(-1);
         }

         <i>// Replace the include by all statements in %MAIN%::%run%</i>
         AST_class_def* main = php_script-&gt;get_class_def("%MAIN%");
         AST_method* run = main-&gt;get_method("%run%");
         out-&gt;push_back_all(run-&gt;statements);
      }
   }
};
</pre>

			<h2> What's Next? </h2>
			
			<p> This is the last tutorial in this series on using the
			<code>Tree_visitor</code> and <code>Tree_transform</code> classes.
			Of course, there is no substitute for experimentation: if you
			really want to understand how things works, you should implement
			your own transforms. Hopefully, the tutorials will help you do so.
			The following sources should also be useful: </p>
			
			<ul>
			<li>The <a href="grammar.html">grammar specification</a> (and the definition of the <a href="maketeatheory.html">grammar formalism</a>)
			<li>The explanation of how PHP gets <a href="representingphp.html">represented</a> in the abstract syntax
			<li>The definition of the C++ classes for the AST nodes in <tt>&lt;phc/ast.h&gt;</tt>
			<li>The definition of the <code>Tree_visitor</code> and <code>Tree_transform</code> classes in <tt>&lt;phc/Tree_visitor.h&gt;</tt> and <tt>&lt;phc/Tree_transform.h&gt;</tt> respectively
			</ul>

			<p> And of course, we are more than happy to answer any other
			questions you might still have. Just send an email to the <a
			href="../contact.html">mailing list</a> and we'll do our best to
			answer you as quickly as possible! Happy coding! </p>

		</td></tr>
		<tr>
			<td style="border-top: solid #8a7640 1px; font-size: 8pt; background-color: #efdca5;">
				$LastChangedDate: 2007-01-17 15:55:22 +0000 (Wed, 17 Jan 2007) $. Contents &copy; the <a href="../authors.html">authors</a>.
			</td>
		</tr>
		</table>
	</body>
</html>
