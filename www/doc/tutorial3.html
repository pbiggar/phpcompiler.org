<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>phc -- Tutorial 3: Restructuring the Tree</title>
		<link rel="stylesheet" type="text/css" href="../phc.css">
	</head>
	<body>
		<table width="796" align="center" cellspacing="0" cellpadding="2" style="border: #8a7640 solid 1px;">
		<tr>
			<td height="149" style="background: url(../img/header.png);">&nbsp;</td>
		</tr>
		<tr>
			<td style="color: white; background-color: #8a7640;">
				<a class="nav" href="../index.html">Home</a> | 
				<a class="nav" href="../src/index.html">Downloads</a> | 
				<a class="nav" href="../doc/index.html">Documentation</a> |
				<a class="nav" href="../plugins/index.html">Plugins</a> |
				<a class="nav" href="../spinoffs/index.html">Spinoff Projects</a> |
				<a class="nav" href="../contact.html">Mailing List</a>
			</td>
		</tr>
		<tr><td style="padding: 5px;">
			<h1>Tutorial 3: Restructuring the Tree</h1>

			<p>Now that we have seen in <a href="tutorial1.html">Tutorial 1</a>
			how we can traverse the tree, and in <a href="tutorial2.html">Tutorial
			2</a> how we can modify individual nodes in the tree, in this tutorial
			we will look at modifying the structure of the tree itself.</p>	

			<p>The transform that we will be considering in this tutorial is one
			that is used in <span class="phc">phc</span> itself. The transform is
			called <code>Remove_concat_null</code> and can be found in
			<tt>process_ast/Remove_concat_null.h</tt>. The purpose of the
			transform is to remove string concatenation with the empty string.
			For example, </p>

<pre>
&lt;?<b>php</b>
   $s = "foo" . "";
?&gt;
</pre>

			<p> is translated to </p>

<pre>
&lt;?<b>php</b>
   $s = "foo";
?&gt;
</pre>

			<p> The reason that this transform is implemented in <span
			class="phc">phc</span> is due to how the <span class="phc">phc</span>
			parser deals with in-string syntax. For example, if you write </p>

<pre>
$a = "foo $b bar";
</pre>

			<p> the corresponding tree generated by <span class="phc">phc</span>
			is </p>

<pre>
$a = "foo " . $b . " bar";
</pre>


			<p> In other words, the variables are pulled out of the string, and
			the various components are then concatenated together. However, taken
			to its logical conclusion, that means that if you write </p>

<pre>
$a = "foo $b";
</pre>

			<p> the parser generates </p>

<pre>
$a = "foo " . $b . "";
</pre>

			<p> Obviously, the second concatenation is unnecessary, and the
			<code>Remove_concat_null</code> transform cleans this up. In this
			tutorial we will explain how this transform can be written. </p>

			<h2> Introducing the <code>Tree_transform</code> API </h2>

			<p> Concatenation is a binary operator, so we are interested in nodes
			of type <code>AST_bin_op</code>. If you check the grammar or,
			alternatively, <tt>ast.h</tt>, you will find that
			<code>AST_bin_op</code> has three attributes: a <code>left</code> and
			a <code>right</code> expression (of type <code>AST_expr</code>) and
			the operator itself (<code>Token_op* op</code>).  Thus, we are
			interested in nodes of type <code>AST_bin_op</code> whose
			<code>op</code> equals the single dot (for string concatenation). </p>
			
			<p> Based on the previous two tutorials, we might try something like
			this: </p>

<pre>
<b>class</b> Remove_concat_null : <b>public</b> Tree_visitor
{
<b>public</b>:
   <b>void</b> pre_bin_op(AST_bin_op* in)
   {
      <i>// Find concat operators</i>
      <b>if</b>(*in-&gt;op-&gt;value == ".")
      {
         // ...
      }
   }
}
</pre>

			<p> The problem is, what are we going to do inside the
			<code>if</code>? Tree visitors can only inspect and modify
			<code>in</code>; they cannot restructure the tree. In particular, we
			cannot replace <code>*in</code> by a new node. For this purpose, <span
			class="phc">phc</span> offers a separate API, the tree
			<i>transformation</i> API. It looks very similar to the tree visitor
			API, but there are two important differences. First, the
			<code>pre</code> and <code>post</code> methods can modify the
			structure of the tree by returning new nodes. Second, there are no
			&ldquo;generic&rdquo; methods in the tree transform API. So, it is not
			possible to define a transformation that would replace all statements
			by something else. (It is not clear how that would be useful, anyway.)
			</p>

			<p> So, we need to write our transformation using the
			<code>Tree_transform</code> API, defined in
			<tt>generated/Tree_transform.h</tt>. Restructuring the class above
			yields </p>

<pre>
<b>class</b> Remove_concat_null : <b>public</b> <span class="box">Tree_transform</span>
{
<b>public</b>:
   <span class="box">AST_expr*</span> pre_bin_op(AST_bin_op* in)
   {
      <i>// Find concat operators</i>
      <b>if</b>(*in-&gt;op-&gt;value == ".")
      {
         // ...
      }
   }
}
</pre>
			
			<p> The differences between the previous version have been
			highlighted. We inherit from a different class, and
			<code>pre_bin_op</code> now has a return value, which is the node that
			will replace <code>*in</code>. If you check the default implementation
			of <code>pre_bin_op</code> in <tt>generated/Tree_transform.cpp</tt>,
			you'll find: </p>

<pre>
AST_expr* Tree_transform::pre_bin_op(AST_bin_op* in)
{
   <b>return</b> in;
}
</pre>
			
			<p> The <code><b>return</b> in;</code> is very important; as we
			mentioned before, the return value of <code>pre_bin_op</code> will
			replace <code>*in</code> in the tree. Therefore, if we don't want to
			replace <code>*in</code>, or perhaps if we want to replace
			<code>*in</code> only if a particular condition holds, we must return
			<code>in</code>. This will replace <code>*in</code> by <code>in</code>
			itself. </p>
			
			<p> The second thing to note is that the return type of
			<code>pre_bin_op</code> is <code>AST_expr</code> instead of
			<code>AST_bin_op</code>. This means that we can replace a binary
			operator node by another other expression node. The <a
			href="maketeatheory.html">maketea theory</a> explains exactly how
			the signatures for the <code>pre</code> and <code>post</code>
			methods are derived, but in most cases they are what you'd expect.
			The easiest way to check is to simply look them up in
			<tt>&lt;phc/Tree_transform.h&gt;</tt>. </p> 

			<h2><a name="implementation">The Implementation</a></h2> 

			<p> We wanted to get rid of useless concatenation operators. To be
			precise, if the binary operator is the concatenation operator, and the
			left operand is the empty string, we want to replace the node by the
			right operand; similarly, if the right operand is the empty string, we
			want to replace the operator by its left operand. Here's the full
			transform: </p>
	
<pre>
<b>class</b> Remove_concat_null : <b>public</b> Tree_transform
{
<b>public</b>:
   AST_expr* post_bin_op(AST_bin_op* in)
   {
      Token_string* empty = <b>new</b> Token_string(<b>new</b> String(""), <b>new</b> String(""));

      <i>// Replace with right operand if left operand is the empty string</i>
      <b>if</b>(in-&gt;match(<b>new</b> AST_bin_op(empty, WILDCARD, ".")))
         <b>return</b> in-&gt;right;

      <i>// Replace with left operand if right operand is the empty string</i>
      <b>if</b>(in-&gt;match(<b>new</b> AST_bin_op(WILDCARD, empty, ".")))
         <b>return</b> in-&gt;left;
      
      <b>return</b> in;
   }
}
</pre>

			<p> We already explained what <code>match</code> does in the <a
			href="tutorial2.html">previous tutorial</a>, but we have not yet
			explained the use of wildcards. If you are using a wildcard
			(<code>WILDCARD</code>) in a pattern passed to <code>match</code>,
			<code>match</code> will not take that subtree into account. Thus, </p> 
	
<pre>
<b>if</b>(in-&gt;match(<b>new</b> AST_bin_op(empty, WILDCARD, ".")))
</pre>
			
			<p> can be paraphrased as &ldquo;is <code>in</code> a binary operator
			with the empty string as the left operand and <code>"."</code> as the
			operator (I don't care about the right operand)?&ldquo; </p>

			<p> Note that the constructor for <code>Token_string</code> has two
			arguments: one corresponds to the value of the string, and one
			corresponds to the representation of the string in the source (see
			also the explanation of the token classes in <a
			href="tutorial2.html">Tutorial 2</a>). For most strings, both of these
			values are the same; however, in some cases they are different. For
			example, <code>value</code> might be set to
			<code>&ldquo;/home/joe/myscript.php</code>, while
			<code>source_rep</code> is set to <code>__FILE__</code>. </p>

			<h2> Running Transformations </h2>

			<p> Recall from the previous two tutorials that visitors are run
			with a call to <code>visit</code>: </p>

<pre>
<b>extern</b> "C" <b>void</b> process_ast(AST_php_script* php_script)
{
    SomeVisitor visitor;
    php_script-&gt;visit(&amp;visitor);
}
</pre>

			<p> Likewise, transformations are run with a call to (you guessed
			it :) <code>transform</code>: </p>

<pre>
<b>extern</b> "C" <b>void</b> process_ast(AST_php_script* php_script)
{
    SomeTransform transform;
    php_script-&gt;transform(&amp;transform);
}
</pre>

			<p> Note however than when invoked like this, the transform should
			not replace the top-level node in the AST (the
			<code>AST_php_script</code> node itself). </p> <h2> A Subtlety
			</h2>

			<p> If you don't understand this section right now, don't worry about
			it; you might find it useful to read it again after having gained some
			experience with the transformation API. </p>

			<p> We have implemented the transform as a <i>post-</i>transform
			rather than a <i>pre-</i> transform. Why? Suppose we implemented the
			transform as a pre-transform. Consider the following PHP expression 
			(bracketed explicitly for emphasis:) </p>

<pre>
("" . $a) . ""
</pre>

			<p> The first binary operator we encounter is the second one (get
			<span class="phc">phc</span> to print the tree if you don't see why.)
			So, we apply the transform and replace the operator by its left
			operand, which happens to be <code>("" . $a)</code>. We then continue
			<i>and transform the children of the that node</i>, because that is
			how the tree transform API is defined. But the <i>children</i> of that
			node are <code>""</code> and <code>$a</code>. So, that means that the
			other binary operator itself will never be processed! </p>

			<p> There are two solutions to this problem. The first is the one we
			used above, and use a post-transform instead of a pre-transform. You
			should try to reason out why this works, but a rule of thumb is that
			unless there is a good reason to use a pre-transform, it's safer to
			use the post-transform, because in the post-transform the children of
			the node have already been transformed, so that you are looking at the
			&ldquo;final&rdquo; version of the node. </p>

			<p> The second solution is to use a pre-transform, but explicitly
			tell <span class="phc">phc</span> to transform the new node in
			turn.  This is the less elegant solution, but sometimes this is the
			only solution that will work (see for example the
			<code>Token_conversion</code> transform in the <span
			class="phc">phc</span> source tree). To do this, you would replace
			</p>
         
<pre>
<b>return</b> in-&gt;right;
</pre>

			<p> by </p>

<pre>
<b>return</b> in-&gt;right-&gt;pre_transform(this);
</pre>

			<h2> What's Next? </h2>
			
			<p> The next tutorial in this series, <a
			href="tutorial4.html">Tutorial 4</a>, introduces a very important
			notion in transforms: the use of <i>state</i>. </p>

		</td></tr>
		<tr>
			<td style="border-top: solid #8a7640 1px; font-size: 8pt; background-color: #efdca5;">
				$LastChangedDate: 2007-01-17 15:55:22 +0000 (Wed, 17 Jan 2007) $. Contents &copy; the <a href="../authors.html">authors</a>.
			</td>
		</tr>
		</table>
	</body>
</html>
