<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>phc -- Overview of the AST classes and transformation API</title>
		<link rel="stylesheet" type="text/css" href="../phc.css">
	</head>
	<body>
		<table width="796" align="center" cellspacing="0" cellpadding="2" style="border: #8a7640 solid 1px;">
		<tr>
			<td height="149" style="background: url(../img/header.png);">&nbsp;</td>
		</tr>
		<tr>
			<td style="color: white; background-color: #8a7640;">
				<a class="nav" href="../index.html">Home</a> | 
				<a class="nav" href="../src/index.html">Downloads</a> | 
				<a class="nav" href="../doc/index.html">Documentation</a> |
				<a class="nav" href="../plugins/index.html">Plugins</a> |
				<a class="nav" href="../spinoffs/index.html">Spinoff Projects</a> |
				<a class="nav" href="../contact.html">Mailing List</a>
			</td>
		</tr>
		<tr><td style="padding: 5px;">
			<h1>Overview of the AST classes and transformation API</h1>

			<p> This document explains the code for the AST classes, tree visitor
			API and tree transformation API. All this code is generated by a tool
			called <span class="phc">maketea</span>. It does not explain how this
			code is derived from the <span class="phc">phc</span> grammar; some of
			the details of this process are explained in the <a
			href="maketeatheory.html">maketea theory</a>.
			
			<h2>The AST classes</h2>

			<p> There are two main kinds of AST classes: classes that correspond
			to non-terminals in the grammar, and classes that correspond to
			terminals in the grammar. These two kinds are called
			<code>AST_xxx</code> and <code>Token_xxx</code> respectively. Examples
			are <code>AST_while</code>, <code>AST_expr</code>,
			<code>Token_method_name</code> and <code>Token_int</code>. </p>
			
			<p> The main difference is that terminal classes have one additional
			field (and sometimes two). Every token class gets an attribute called
			<code>value</code>. The type of this attribute depends on the token;
			for most tokens it is <code>String*</code> (this is the default);
			however, if the grammar explicitely specifies a type for the value (in
			angular brackets, for example <code>REAL&lt;double&gt;</code>), this
			overrides the default. If the default value is overridden, the token
			class gets an additional attribute <code>source_rep</code>, which
			corresponds to the value of the token in the source value. The type of
			<code>source_rep</code> is always <code>String*</code>. For example,
			the real number <code>5E-1</code> might have <code>value</code> set to
			the <code>double</code> 0.5, but <code>source_rep</code> set to
			<code>&ldquo;5E-1&rdquo;</code>. Similarly, a string <code>__FILE__</code>
			might have <code>value</code> set to
			<code>/home/joe/myscript.php</code>, but <code>source_rep</code> set
			to <code>__FILE__</code>. If the type of the <code>value</code>
			attribute it set to be empty, the token class does not get a value but
			(but it will get a <code>source_rep</code> field). This is the case
			for <code>Token_null&lt;&gt;</code> in the <span
			class="phc">phc</span> grammar. </p>
			
			<p> In addition, all the tokens classes have a method called
			<code>get_value_as_string()</code> and a method
			<code>get_source_rep</code> when applicable. This is useful for
			programs that operate on general <code>AST_identifier</code> objects
			(such as <code>Token_method_name</code> or
			<code>Token_class_name</code>) or <code>AST_literal</code> (such as
			<code>Token_real</code> or <code>Token_int</code>). Note that the
			value returned by <code>get_value_as_string()</code> and
			<code>get_source_rep()</code> may be different; for example,
			<code>get_source_rep()</code> might return <code>0.5E-1</code>, while
			<code>get_value_as_string()</code> might return <code>0.5</code>. </p>

			<p> All (non-terminal and terminal) then provide the following methods
			for deep equality, pattern matching, cloning, calling a tree visitor
			and calling a tree transformer. These methods are explained separately
			in sections below. </p>

			<h2>Deep Equality</h2>

			<p> Deep equality is implemented by <code>bool deep_equals(Object*
			other)</code>. It takes into account the entire tree structure
			generated by <span class="phc">maketea</span>, including any fields
			that are specified in the <a href="grammar.html#mixin">mixin code</a>
			in the grammar. Thus, <code>deep_equals</code> also compares line
			numbers, comments, etc.  </p>

			<h2>Cloning</h2>

			<p> Cloning is implemented by <code>deep_clone</code>. Cloning makes a
			(deep) copy of a tree, so the set of all pointers in the new tree is
			completely distinct from the set of pointers in the old tree. The only
			exception to this rule is that cloning the <code>WILDCARD</code>
			objects (see pattern matching, below) returns the
			<code>WILDCARD</code> object itself. </p> 

			<h2>Pattern Matching</h2>

			<p> Pattern matching is implemented by <code>bool match(Object*
			pattern)</code>. Pattern matching differs from deep equality in two
			ways. First, it does not take into account any fields added by the
			mixin code; for example, it does not compare line numbers or comments.
			</p>

			<p> Second, <code>match</code> supports the use of wildcards. <span
			class="phc">maketea</span> generates a special class called
			<code>Wildcard</code>. You should never instantiate this class
			directly; in <tt>&lt;phc/ast.h&gt;</tt>, you will find the
			following declaration: </p> 

<pre>
<b>extern</b> Wildcard* WILDCARD;
</pre>

			<p> This <code>WILDCARD</code> is the sole instance of
			<code>Wildcard</code>. When <code>match</code> encounters a reference
			to this object in a pattern, it does two things: it skips that field
			in the comparison (so it acts as a &ldquo;don't care&rdquo;), and it
			replaces the value of the field in the pattern by the value in the
			tree. For example, in the body of the <code>if</code> in </p>

<pre>
Token_class_name* name = <b>new</b> Token_class_name(<b>new</b> String("SOME_CLASS"));
Token_class_name* pattern = <b>new</b> Token_class_name(WILDCARD);

<b>if</b>(name-&gt;match(pattern))
{
   <i>// ...</i>
}
</pre>

			<p><code>pattern->value</code> will be set to the corresponding
			value in <code>name</code>. Tutorials <a href="tutorial3.html">3</a>
			and <a href="tutorial4.html">4</a> include examples of the use of
			wildcards. </p>

			<p> Calling any methods on the <code>WILDCARD</code> object other than
			<code>deep_clone</code> will lead to a runtime error. </p>

			<h2> The Tree Visitor API </h2>

			<table><tr>
			<td valign="top">
			<img alt="sequence diagram" src="generatedcode/visitor.png">
			</td>
			<td valign="top">

			<p> Every AST class provides four methods to support the tree visitor
			API: <code>void visit(Tree_visitor*)</code>,
			<code>void pre_visit(Tree_visitor*)</code>,
			<code>void visit_children(Tree_visitor*)</code> and
			<code>void post_visit(Tree_visitor*)</code>. The implementation of each of
			these methods is very simple. </p>

			<p><code>visit</code> simply calls <code>pre_visit</code>, <code>visit_children</code> and <code>post_visit</code> in order. It could have been implemented once and for all in the <code>AST_node</code> class (but is not, for no particular reason). </p>

			<p>For a node <code>x0</code>, which inherits from <code>x1</code>,
			which inherits from <code>x2</code>, which in turn inherits from
			<code>x3</code>, etc., <code>x0::pre_visit</code> calls
			<code>pre_x3</code>, <code>pre_x2</code>, <code>pre_x1</code> and
			<code>pre_x0</code>, in that order, on the tree visitor object,
			passing itself as an argument.  If <code>x0</code> inherits from
			multiple classes, all of the appropriate visitor methods will be
			invoked. However, if <code>x0</code> inherits from both
			<code>x1a</code> and <code>x1b</code>, the programmer should not rely
			on the relative order of <code>pre_x1a</code> and
			<code>pre_x1b</code>. </p>

			<p><code>x0::visit_children</code> simply calls <code>children_x0</code>.</p>

			<p><code>x0::post_visit</code> will call <code>post_x0</code>,
			<code>post_x1</code>, etc. Again, if <code>x0</code> inherits from
			both <code>x1a</code> and <code>x1b</code>, the programmer should not
			rely on the relative order of <code>post_x1a</code> and
			<code>post_x1b</code>. The only guarantee made by <span
			class="phc">maketea</span> is that the order of the pre-methods will
			be the exact reverse of the order of the post-methods. </p>
		
			</td>
			</tr></table>

			<h2>The Tree Transform API </h2>

			<center>
			<img alt="sequence diagram" src="generatedcode/transform.png">
			</center>

			<p> Every AST class <code>AST_foo</code>, which inherits from
			<code>AST_gen_foo</code> provides four methods to support the tree
			visitor API: <code>AST_gen_foo* transform(Tree_transformer*)</code>,
			<code>AST_gen_foo* pre_transform(Tree_transformer*)</code>, <code>void
			transform_children(Tree_transformer*)</code> and <code>AST_gen_foo*
			post_transform(Tree_transformer*)</code>. It is not entirely as
			straightforward as this; if <code>AST_foo</code> inherits from more
			than one class, the return type would probably be
			<code>AST_foo</code>; in some cases, <code>transform</code> might
			return a <code>AST_foo_list</code> instead. See the section on <a
			href="maketeatheory.html#contextresolution">context resolution</a>
			in the grammar formalism for details; here we consider the
			programmer's perspective only. The exact signatures for a particular
			class can always be found in <tt>generated/ast.h</tt>. </p>

			<p> As with the tree visitor API, <code>transform</code> calls
			<code>pre_transform</code>, <code>transform_children</code> and
			<code>post_transform</code>. However, while <code>transform</code>
			calls <code>pre_transform</code> on itself, it calls
			<code>transform_children</code> and <code>post_transform</code> on the
			node returned by <code>pre_transform</code>. If
			<code>pre_transform</code> returns a vector, <code>transform</code>
			calls <code>transform_children</code> and <code>post_transform</code>
			on every element in that vector, assembling all the results. </p>

			<p> <code>pre_transform</code> and <code>post_transform</code> simply
			call the appropriate method in the <code>Tree_transform</code> object.
			However, if <code>pre_transform</code> (or
			<code>post_transform</code>) returns a list of nodes, the
			corresponding method in the tree transform object will expect two
			arguments: the node to be transformed, and an empty list of nodes that
			will be the return value of <code>pre_transform</code>. In that case,
			<code>pre_transform</code> will first create a new empty list, pass
			that in as the second argument to the corresponding method in the tree
			transform object, and then return that list. </p>

			<p> <code>transform_children</code> just calls the corresponding method
			in the tree transform object. </p>
		</td></tr>
		<tr>
			<td style="border-top: solid #8a7640 1px; font-size: 8pt; background-color: #efdca5;">
				$LastChangedDate: 2007-01-17 15:55:22 +0000 (Wed, 17 Jan 2007) $. Contents &copy; the <a href="../authors.html">authors</a>.
			</td>
		</tr>
		</table>
	</body>
</html>
