<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>phc -- Tutorial 1: Traversing the Tree</title>
		<link rel="stylesheet" type="text/css" href="../phc.css">
	</head>
	<body>
		<table width="796" align="center" cellspacing="0" cellpadding="2" style="border: #8a7640 solid 1px;">
		<tr>
			<td height="149" style="background: url(../img/header.png);">&nbsp;</td>
		</tr>
		<tr>
			<td style="color: white; background-color: #8a7640;">
				<a class="nav" href="../index.html">Home</a> | 
				<a class="nav" href="../src/index.html">Downloads</a> | 
				<a class="nav" href="../doc/index.html">Documentation</a> |
				<a class="nav" href="../plugins/index.html">Plugins</a> |
				<a class="nav" href="../spinoffs/index.html">Spinoff Projects</a> |
				<a class="nav" href="../contact.html">Mailing List</a>
			</td>
		</tr>
		<tr><td style="padding: 5px;">
			<h1>Tutorial 1: Traversing the Tree</h1>

			<p> In <a href="gettingstarted.html">Getting Started</a>, we explained
			that <span class="phc">phc</span> represents PHP scripts internally as
			an abstract syntax tree, and that the structure of this tree is
			determined by the <a href="grammar.html">grammar</a>. We then showed
			how to make use of this tree to count the number of classes.  In this
			tutorial, we will consider an equally simple task: we want to count
			the number of function calls in a script. So, for the following PHP script, </p>
		
<pre>
&lt;?<b>php</b>
   <b>echo</b> "Hello ";
   <b>echo</b> "world!";
?&gt;
</pre>

			<p> we should report two function calls. </p>

			<p> Note that all the plugins that we will develop in these
			tutorials are included in the <span class="phc">phc</span>
			distribution. For example, in this tutorial we will be developing
			two plugins: a difficult solution to the problem and an easy
			solution to the problem. You can run these plugins by running </p>

<pre>
phc --run plugins/tutorials/count_function_calls_difficult.so hello.php
</pre>
			
			or

<pre>
phc --run plugins/tutorials/count_function_calls_easy.so hello.php
</pre>

			<h2>The Grammar (Revisited)</h2>
			
			<p> How do we go about counting the number of function calls in a
			script? Remember that, as far as <span class="phc">phc</span> is
			concerned, a PHP script consists of a number of classes (and interface
			definitions). Each of these classes may have one or more methods, and
			each method can have one or more statements in them. Simplified, the
			grammar would state this as: </p>

<pre>
php_script ::= class_def+ ;
class_def ::= CLASS_NAME member* ; 
member ::= method | attribute ;
method ::= signature statement* ;
signature ::= METHOD_NAME formal_parameter* ; 
</pre>

			<p>where the vertical bar (<code>|</code>) means &ldquo;or&rdquo;.
			Thus, our running example is represented by the following tree.</p>

			<center>
			<img src="tutorial1/tutorial1-simplified.png" style="border: thin solid #8a7640;" alt="Simplified AST">
			</center>

			<p>(Note that this tree is simplified from the real tree; not all
			nodes are shown. You can also view the <a href="tutorial1/tutorial1.png"
			target="_blank">full tree</a>). </p>

			<h2>Statements and Expressions</h2>

			<p> The two nodes that we are interested in are the &ldquo;method
			invocation&rdquo; nodes. The <code>eval expr</code> nodes just above
			them probably need some explanation. There are many different types of
			statements in PHP: <code>if</code>-statements,
			<code>while</code>-statements, <code>for</code>-loops, etc. You can
			find the full list in the <a href="grammar.html">grammar</a>. If you
			do look at the grammar, you will notice in particular that a function
			call is not actually a statement! Instead, a function call is an
			<i>expression</i>. </p> 

			<p> The difference between statements and expressions is that a
			statement <i>does</i> something (for example, a <code>for</code>-loop
			repeats a bunch of other statements), but an expression has a
			<i>value</i>. For example, &ldquo;5&rdquo; is an expression (with
			value 5), &ldquo;1+1&rdquo; is an expression (with value 2), etc. A
			function call is also considered an expression. The value of a
			function call is the value that the function returns. </p>

			<p> Now, the node <code>eval expr</code> makes a statement from an
			expression. So, if you want to use an expression where <span
			class="phc">phc</span> expects a statement, you have to use the
			grammar rule </p>

<pre>
statement ::= ... | eval_expr ;
eval_expr ::= expr ;
</pre>

			<h2>The Difficult Solution</h2>

			<p> The following plugin counts the number of function calls in a
			tree. If you do not understand the code, do not worry! We will look
			at a much easier solution in a second. If you understand the
			comments, that is enough.  </p>
			
<pre>
#include &lt;phc/ast.h&gt;

<b>extern</b> "C" <b>void</b> process_ast(AST_php_script* php_script)
{
   AST_class_def_list::const_iterator ci;
   AST_member_list::const_iterator mi;
   AST_statement_list::const_iterator si;
   
   AST_method* method;
   AST_eval_expr* eval_expr;
   AST_method_invocation* invoc;
   
   <b>int</b> num_function_calls = 0;
   
   <i>// Inspect all classes</i>
   <b>for</b>(
      ci = php_script-&gt;class_defs-&gt;begin(); 
      ci != php_script-&gt;class_defs-&gt;end(); 
      ci++)
   {
      <i>// Inspect all members in the class</i>
      <b>for</b>(
         mi = (*ci)-&gt;members-&gt;begin(); 
         mi != (*ci)-&gt;members-&gt;end(); 
         mi++)
      {
         <i>// Check whether this member is a method or an attribute</i>
         method = <b>dynamic_cast</b>&lt;AST_method*&gt;(*mi);
         <b>if</b>(method == <b>NULL</b>) <b>continue</b>;
         
         <i>// Check all statements in the method</i>
         <b>for</b>(
            si = method-&gt;statements-&gt;begin(); 
            si != method-&gt;statements-&gt;end(); 
            si++)
         {
            <i>// Check if the statement is of type "eval_expr"</i>
            eval_expr = <b>dynamic_cast</b>&lt;AST_eval_expr*&gt;(*si);
            <b>if</b>(eval_expr == <b>NULL</b>) <b>continue</b>;
   
            <i>// Finally, check <b>if</b> the expression is a function call</i>
            invoc = <b>dynamic_cast</b>&lt;AST_method_invocation*&gt;(eval_expr-&gt;expr);
            <b>if</b>(invoc == <b>NULL</b>) <b>continue</b>;
   
            <i>// Yeah! We found a function call</i>
            num_function_calls++;
         }
      }
   }
   
   printf("%d function calls found\n", num_function_calls);
}
</pre>

			<p> Why is this code so complicated? First of all, it has to search
			through the entire tree, looking for function calls. Because function
			calls are fairly deep down in the tree, we need a lot of code simply
			to find them. The second complication is the fact that, for example, a
			class consists of &ldquo;members&ldquo;. A member is either an
			attribute or a method, but we are interested only in methods.
			Similarly, a method consists of &ldquo;statements&ldquo;. A statement
			can be one of many things; but we are only interested in
			<code>eval_expr</code> statements. Thus, we have to test nodes for
			their type (using <code>dynamic_cast</code>). </p>

			<h2>The Easy Solution</h2>

			<p> Fortunately, <span class="phc">phc</span> will do all this for you
			automatically! There is a standard &ldquo;do-nothing&rdquo; tree
			traversal predefined in <span class="phc">phc</span> in the form of a
			class called <code>Tree_visitor</code> (defined in
			<tt>&lt;phc/Tree_visitor.h&gt;</tt>). <code>Tree_visitor</code>
			contains methods for each type of node in the tree. <span
			class="phc">phc</span> will automatically traverse the abstract syntax
			tree for you, and call the appropriate method at each node. </p>

			<p> In fact, there are <i>two</i> methods defined for each type of
			node. The first method, called <code>pre_something</code>, gets called
			on a node <i>before</i> <span class="phc">phc</span> visits the
			children of the node. The second method, called
			<code>post_something</code>, gets called on a node <i>after</i> <span
			class="phc">phc</span> has visited the children of the node. For
			example, <code>pre_method</code> gets called on an
			<code>AST_method</code>, before visiting the statements in the method.
			After all statements have been visited, <code>post_method</code> gets
			called. Thus, the very first method that gets called is
			<code>pre_php_script</code> (because that is the top-level node in the
			tree), and the very last method that gets called is
			<code>post_php_script</code>. </p>

			So, here is an alternative and much easier solution for our problem.

<pre>
#include &lt;phc/Tree_visitor.h&gt;

<b>class</b> Count_function_calls : <b>public</b> Tree_visitor
{
<b>private</b>:
   <b>int</b> num_function_calls;

<b>public</b>:
   <i>// Set num_function_calls to zero before we begin</i>
   <b>void</b> pre_php_script(AST_php_script* in)
   {
      num_function_calls = 0;
   }

   <i>// Print the number of function calls when we are done</i>
   <b>void</b> post_php_script(AST_php_script* in)
   {
      printf("%d function calls found\n", num_function_calls);
   }
   
   <i>// Count the number of function calls</i>
   <b>void</b> post_method_invocation(AST_method_invocation* in)
   {
      num_function_calls++;
   }
};

<b>extern</b> "C" <b>void</b> process_ast(AST_php_script* php_script)
{
   Count_function_calls cfc;
   php_script-&gt;visit(&amp;cfc);
}
</pre>

			<p> The real work in this transform is now done by the visitor; the
			only task left that <code>process_ast</code> still has to do is
			instanstiate the visitor and run it over the tree. </p>

			<h2>Counting All Statements</h2> 

			<p> (The plugin explained in this section is available as
			<tt>plugins/tutorials/count_statements.so</tt> in the <span
			class="phc">phc</span> distribution.)  </p>

			<p> Suppose we wanted to count all statements, rather than just
			function calls. We could define methods for <code>eval_expr</code>,
			<code>for</code>, <code>while</code>, <code>if</code>, etc., but
			there is an easier way. If you check the <a
			href="grammar.html">grammar</a>, you will find the following rules:
			</p>

<pre>
statement ::= if | ... ;
commented_node ::= ... | statement | ... ;
node ::= ... | node | ... ;
</pre>
			
			<p> You could read this as &ldquo;an if-statement <i>is-a</i>
			statement, a statement <i>is-a</i> commented node (a node that may
			have comments associated with it), and a commented node <i>is-a</i>
			node. This <i>is-a</i> relation is reflection using inheritance (class
			<code>AST_if</code> inherits from <code>AST_statement</code>), but the
			tree visitor API also has corresponding &ldquo;generic&rdquo; methods.
			For example, the following suffices to count all statements: </p>
			
<pre>
<b>void</b> pre_statement(AST_statement* in)
{
   num_statements++;
}
</pre>
	
			<p> We need to be precise about the order in which <span
			class="phc">phc</span> calls all these methods. Suppose we have a node
			<code>Foo</code> (say, an if-statement), which <i>is-a</i>
			<code>Bar</code> (say, statement), which itself <i>is-a</i>
			<code>Baz</code> (say, commented node). Then <span
			class="phc">phc</span> calls the visitor methods in the following
			order: </p>

			<ol>
			<li><code>pre_baz</code>
			<li><code>pre_bar</code>
			<li><code>pre_foo</code>
			<li><code>children_foo</code> (visit the children of <code>foo</code>)
			<li><code>post_foo</code>
			<li><code>post_bar</code>
			<li><code>post_baz</code>
			</li>
			</ol>

			<p> Just to emphasise, if all of the visitor methods listed above
			are implemented, they will <i>all</i> be invoked, in the order
			listed above. So, implementing a more specific visitor
			(<code>pre_foo</code>) does not inhibit the more general method
			(<code>pre_bar</code>) from being invoked. You can run the
			<tt>plugins/tutorials/show_traversal_order.so</tt> from the
			<span class="phc">phc</span> distribution to see this in action.
			</p>

			<h2> What's Next? </h2>

			<p> To find out how you can modify the tree, continue with <a
			href="tutorial2.html">Tutorial 2</a>. </p>

		</td></tr>
		<tr>
			<td style="border-top: solid #8a7640 1px; font-size: 8pt; background-color: #efdca5;">
				$LastChangedDate: 2007-01-17 15:55:22 +0000 (Wed, 17 Jan 2007) $. Contents &copy; the <a href="../authors.html">authors</a>.
			</td>
		</tr>
		</table>
	</body>
</html>
