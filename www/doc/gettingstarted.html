<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>phc -- Getting Started</title>
		<link rel="stylesheet" type="text/css" href="../phc.css">
	</head>
	<body>
		<table width="796" align="center" cellspacing="0" cellpadding="2" style="border: #8a7640 solid 1px;">
		<tr>
			<td height="149" style="background: url(../img/header.png);">&nbsp;</td>
		</tr>
		<tr>
			<td style="color: white; background-color: #8a7640;">
				<a class="nav" href="../index.html">Home</a> | 
				<a class="nav" href="../src/index.html">Downloads</a> | 
				<a class="nav" href="../doc/index.html">Documentation</a> |
				<a class="nav" href="../plugins/index.html">Plugins</a> |
				<a class="nav" href="../spinoffs/index.html">Spinoff Projects</a> |
				<a class="nav" href="../contact.html">Mailing List</a>
			</td>
		</tr>
		<tr><td style="padding: 5px;">
			<h1>Getting Started</h1>
			
			For this introductory tutorial, we assume that you have
			successfully downloaded and installed <span class="phc">phc</span>,
			and that you know how to run it (see the <a
			href="install.html">Installation Instructions</a> and <a
			href="runningphc.html">Running phc</a>). This tutorial gets you
			started with using <span class="phc">phc</span> to develop your own
			tools for PHP by writing plugins.

			<h2>Compiling a Plugin</h2>

			<p> To get up and running, we'll first write a &ldquo;hello
			world&rdquo; plugin that does nothing except print a string. Create a
			new directory, say <tt>~/myplugins</tt> and create a new file
			<tt>helloworld.cpp</tt>: </p>

<pre>
<b>#include</b> &lt;phc/ast.h&gt;
<b>#include</b> &lt;iostream&gt;

<b>using namespace</b> std;

<b>extern</b> "C" <b>void</b> process_ast(AST_php_script* php_script)
{
   cout &lt;&lt; "Hello world (I'm a phc plugin!)" &lt;&lt; endl;
}
</pre>

			<p> This is an example of a minimal plugin. Every plugin you write
			must contain a <code>process_ast</code> method with this exact
			signature. To compile the plugin, run </p>

<pre>
~/myplugins$ phc_compile_plugin helloworld.cpp -o helloworld.so
</pre>

			<p> (<code>phc_compile_plugin</code> is a small shellscript that makes
			the task of compiling plugins easier; all it does is call
			<code>g++</code> with a couple of options; if you're curious, you can
			open it in any text editor.) Finally, run the plugin using </p>

<pre>
~/myplugins$ phc --run helloworld.so sometest.php
</pre>

			<p> (You need to pass in an input script to <code>phc</code> even
			though our plugin does not use it.) If that worked as expected,
			congratulations: you've just written your first <span
			class="phc">phc</span> plugin! :-) </p>

				
			<h2>About <code>extern "C"</code></h2>
	
			<p> You may have been wondering what the <code>extern "C"</code> in
			the definition of <code>process_ast</code> is for; the reason is that
			<span class="phc">phc</span> uses the Unix <code>dlopen</code>
			interface to load your plugin; if you do not declare
			<code>process_ast</code> as <code>extern "C"</code>, <span
			class="phc">phc</span> will not be able to find the
			<code>process_ast</code> symbol in your plugin because the name of
			that function will have been mangled by the C++ compiler.
			Incidentally, this does not mean that you cannot write C++ code inside
			<code>process_ast</code>.</p>
	
			<p> If you don't understand any of that, don't worry about it: just
			remember that you need to declare <code>process_ast</code> as
			<code>extern "C"</code> and everything will be fine. (You don't need
			<code>extern "C"</code> for any other functions you might define.) </p>


			<h2>The Abstract Syntax</h2>

			<p> To be able to do anything useful in your plugins, you need to know
			how <span class="phc">phc</span> represents PHP code internally. <span
			class="phc">phc</span>'s view of PHP scripts is described by an
			<i>abstract grammar</i>. An abstract grammar describes how the
			contents of a PHP script are structured. A grammar consists of a
			number of rules. For example, there is a rule in the grammar that
			describes how <code>if</code> statements work: </p>

<pre>
if ::= expr <i>iftrue:</i>statement* <i>iffalse:</i>statement* ; 
</pre>

			<p>
			This rules reads: &ldquo;<i>An <code>if</code> statement consists of
			an expression</i> (the condition of the if-statement), <i>a list of
			statements called `iftrue'</i> (the instructions that get executed
			when the condition holds), <i>and another list of statements called
			`iffalse'</i> (the instructions that get executed when the condition
			does not hold)&rdquo;. The asterisk (<code>*</code>) in the rule means
			&ldquo;list of&rdquo;. 
			</p>
			
			<p> As a second example, consider the rule that describes arrays in
			PHP. This rule should cover things such as <code>array()</code>,
			<code>array("a", "b")</code> and <code>array(1 =&gt; "a", 2 =&gt;
			"g")</code>. Arrays are described by the following two rules.  </p>

<pre>
array ::= array_elem* ;
array_elem ::= <i>key:</i>expr? <i>val:</i>expr ;
</pre>

			<p> (Actually, this is a simplification, but it will do for the
			moment.) These two rules say that &ldquo;<i>an array consists of a
			list of array elements</i>&rdquo;, and an &ldquo;<i>array element has
			an optional expression called `key', and a second expression called
			`val'</i>&rdquo;. The question mark (<code>?</code>) means
			&ldquo;optional&rdquo;. Note that the grammar does not record the need
			for the keyword <code>array</code>, or for the parentheses and commas.
			We do not need to record these, because we already <i>know</i> that we
			are talking about an array; all we need to know is what the array
			elements are. </p>
			
			<h2>The Abstract Syntax Tree</h2>

			<p> When <span class="phc">phc</span> reads a PHP script, it builds up
			an internal representation of the script. This representation is known
			as an <i>abstract syntax tree</i> (or AST for short). The structure of
			the AST follows directly from the abstract grammar. For people
			familiar with XML, this tree can be compared to the DOM representation
			of an XML script (and in fact, <span class="phc">phc</span> can output
			the AST as an <a href="runningphc.html">XML</a> document). </p>
			
			<p> For example, consider <code>if</code>-statements again. An
			<code>if</code>-statement is represented by an instance of the
			<code>AST_if</code> class, which is (approximately) defined as
			follows.  </p>

<pre>
<b>class</b> AST_if
{
<b>public</b>:
   AST_expr* expr;
   AST_statement_list* iftrue;
   AST_statement_list* iffalse;
};
</pre>

		<p> Thus, the name of the rule (<code>if ::= ...</code>) translates into
		a class <code>AST_if</code>, and the elements on the right hand side of
		the rule (<code>expr <i>iftrue:</i>statement*
		<i>iffalse:</i>statement*</code>) correspond directly to the class
		members. The class <code>AST_statement_list</code> inherits from the STL
		<code>list</code> class, and can thus be treated as such. </p>
		
		<p> Similarly, the class definitions for arrays and array elements look
		like </p> 
		
<pre>
<b>class</b> AST_array
{
<b>public</b>:
   AST_array_elem_list* array_elems;
};

<b>class</b> AST_array_elem
{
<b>public</b>:
   AST_expr* key;
   AST_expr* val;
};
</pre>

		<p> When you start developing applications with <span
		class="phc">phc</span> you will find it useful to consult the full
		description of the grammar, which can be found in the <a
		href="grammar.html">Grammar Definition</a>. A detailed explanation of
		the structure of this grammar, and how it converts to the C++ class
		structure, can be found in the <a href="maketeatheory.html">Grammar
		Formalism</a>. Some notes on how <span class="phc">phc</span> converts
		normal PHP code into abstract syntax can be found in <a
		href="representingphp.html">Representing PHP</a>.  </p>

		<h2>Working with the AST</h2>

		<p> When you want to build tools based on <span class="phc">phc</span>,
		you do not have to understand how the abstract syntax tree is built,
		because this is done for you. Once the tree has been built, you can
		examine or modify the tree in any way you want. When you are finished,
		you can ask <span class="phc">phc</span> to output the tree to normal PHP
		code again. </p> 

		<p> Let's write a very simple plugin that counts the number of class
		definitions in a script. If you look at the <a
		href="grammar.html">grammar</a>, you will notice that class definitions
		are represented by a (C++) class called <code>AST_class_def</code>. So,
		we need to count the number of objects of type <code>AST_class_def</code>
		in the tree. Create a new file <tt>~/myplugins/count_classes.cpp</tt>.
		Recall the skeleton plugin: </p>
		
<pre>
<b>#include</b> &lt;phc/ast.h&gt;

<b>extern</b> "C" <b>void</b> process_ast(AST_php_script* php_script)
{
}
</pre>

		<p> You will notice that <code>process_ast</code> gets passed an object of
		type <code>AST_php_script</code>. This is the top-level node of the
		generated AST. If you look at the <a href="grammar.html">grammar</a>, you
		will find that <code>AST_php_script</code> corresponds to the following
		rule: </p>
	
<code>
php_script ::= interface_def* class_def+ ;
</code>

		<p> Thus, as far as <span class="phc">phc</span> is concerned, a PHP
		script consists of a number of interface definitions, followed by a
		number of class definitions (see <a
		href="representingphp.html">Representing PHP</a>).  The plus
		(<code>+</code>) in this rule is similar to an asterisk (<code>*</code>),
		but indicates that there must at least be one item in the list. In other
		words, a PHP script may not have any interface definitions, but it must
		have at least one class definition. </p>

		<p> By now you should be able to deduce that the class
		<code>AST_php_script</code> will have two members, called
		<code>interface_defs</code> and <code>class_defs</code>, both of which
		are lists. So, to count the number of classes, all we have to do is
		query the number of elements in the <code>class_defs</code> vector: </p>

<pre>
<b>#include</b> &lt;phc/ast.h&gt;

<b>extern</b> "C" <b>void</b> process_ast(AST_php_script* php_script)
{
   printf("%d class definition(s) found\n", php_script->class_defs->size());
}
</pre>

		<p> Save this file to <tt>~/myplugins/count_classes.cpp</tt>. Compile:
		</p>

<pre>
~/myplugins$ phc_compile_plugin -o count_classes.so count_classes.cpp
</pre>

		<p> And run: </p>

<pre>
./phc --run count_classes.so hello.php
</pre>

		<h2>Actually...</h2>

		<p> If you actually did try to run your plugin, you might think right
		now that something went wrong: <span class="phc">phc</span> appears to
		report one class definition too many!  However, there is a very good
		reason for this. We said earlier that as far as <span
		class="phc">phc</span> is concerned, a PHP script consists of a number
		of interface definitions, followed by at least one class definition. So
		where does the code that is defined outside of any class go? </p>

		<p> The answer is that any code defined outside any class goes into a
		special class called <code>%MAIN%</code>. Any functions you define that
		do not belong to any class, become members of <code>%MAIN%</code>, and
		any code you write that does not belong to any function, becomes part of
		a special method in <code>%MAIN%</code> called <code>%run%</code>.  When
		<span class="phc">phc</span> outputs the tree back to normal PHP code,
		<code>%MAIN%</code> disappears; however, when you work with the tree,
		there is no distinction between code defined inside and outside classes;
		in the tree, everything is defined as part of some class. This makes the
		tree simpler and easier to work with. </p>

		<p> More details about how the various PHP constructs are represented in
		the abstract grammar can be found in <a
		href="representingphp.html">Representing PHP</a>. </p>

		<h2>Writing Stand Alone Applications</h2>

		If you prefer not to write a plugin but want to modify <span
		class="phc">phc</span> itself to derive a new, stand-alone,
		application, you can modify <code>process_ast</code> in
		<tt>process_ast/process_ast.cpp</tt> in the <span
		class="phc">phc</span> source tree instead. This has the effect of
		&ldquo;hardcoding&rdquo; your plugin into <span class="phc">phc</span>
		(in versions before 0.1.7, this was the only way to write extensions).
		However, in the rest of the tutorials we will assume that you are
		writing your extension as a plugin.

		<h2>What's Next?</h2>

		<p> In theory, you now know enough to start implementing your own tools
		for PHP. Write a new plugin, run the plugin using the
		<code>--run</code> option, and optionally pass in the
		<code>--dump-php</code> option also to request that  <span
		class="phc">phc</span> outputs the tree back to PHP syntax after having
		executed your plugin. </p>

		<p> However, you will probably find that modifying the tree, despite
		being well-defined and easy to understand, is actually rather
		laborious.  It requires a lot of boring boilerplate code. The good news
		is that <span class="phc">phc</span> provides sophisticated support for
		examining and modifying this tree. This is explained in detail in the
		follow-up tutorials: </p>

		<ul>
		<li>Tutorial 1: <a href="tutorial1.html">Traversing the Tree</a>
		<li>Tutorial 2: <a href="tutorial2.html">Modifying Tree Nodes</a>
		<li>Tutorial 3: <a href="tutorial3.html">Restructuring the Tree</a>
		<li>Tutorial 4: <a href="tutorial4.html">Using State</a>
		<li>Tutorial 5: <a href="tutorial5.html">Modifying the Traversal Order</a>
		<li>Tutorial 6: <a href="tutorial6.html">Returning Lists</a>
		</ul>

		</td></tr>
		<tr>
			<td style="border-top: solid #8a7640 1px; font-size: 8pt; background-color: #efdca5;">
				$LastChangedDate: 2007-01-17 15:55:22 +0000 (Wed, 17 Jan 2007) $. Contents &copy; the <a href="../authors.html">authors</a>.
			</td>
		</tr>
		</table>
	</body>
</html>
