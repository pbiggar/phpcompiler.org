<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>phc -- maketea Theory</title>
		<link rel="stylesheet" type="text/css" href="../phc.css">
	</head>
	<body>
		<table width="796" align="center" cellspacing="0" cellpadding="2" style="border: #8a7640 solid 1px;">
		<tr>
			<td height="149" style="background: url(../img/header.png);">&nbsp;</td>
		</tr>
		<tr>
			<td style="color: white; background-color: #8a7640;">
				<a class="nav" href="../index.html">Home</a> | 
				<a class="nav" href="../src/index.html">Downloads</a> | 
				<a class="nav" href="../doc/index.html">Documentation</a> |
				<a class="nav" href="../plugins/index.html">Plugins</a> |
				<a class="nav" href="../spinoffs/index.html">Spinoff Projects</a> |
				<a class="nav" href="../contact.html">Mailing List</a>
			</td>
		</tr>
		<tr><td style="padding: 5px;">
			<h1><span class="phc">maketea</span> Theory</h1>

			<p> <span class="phc">maketea</span> is a tool bundled with <span
			class="phc">phc</span> which, based on a grammar definition of a
			language, generates a C++ hierarchy for the corresponding abstract
			syntax tree, a tree transformation and visitor API, and deep cloning,
			deep equality and pattern matching on the AST. In this document we
			describe the grammar formalism used by <span
			class="phc">maketea</span>, how a C++ class structure is derived from
			such a grammar, and explains how the tree transformation API is
			generated. The generated code itself is explained in <a
			href="generatedcode.html">another document</a>. </p>

	
<h2>The Grammar Formalism</h2>

<p> The style of grammar formalism used by <span class="phc">maketea</span> is
sometimes referred to as an &ldquo;object oriented&rdquo; context free grammar.
It facilitates a trivial and reliable mapping between the <a
href="grammar.html">abstract grammar</a>, and the actual (C++) abstract syntax
tree (AST) that is generated by the <span class="phc">phc</span> parser.  </p>

<p> We make a distinction between three types of symbols: <i>non-terminal</i>
symbols, <i>terminal symbols</i> and <i>markers</i>.  Non-terminal symbols have
the same function in our formalism as in the usual BNF formalism, and will not
be further explained. We denote non-terminal symbols in lower case in the
grammar (e.g., <code>expr</code>).  </p>

<p> The distinction between terminal symbols and markers is non-standard.
Markers have no semantic value other than their presence; an example is
<code>"abstract"</code>. Thus, the semantic value of a marker is a boolean
value; it is either there, or it is not (note that this is different from a
symbol such as the semi-colon, which has <i>no</i> semantic value whatsoever,
and thus does not need to be included in an abstract syntax tree).  Conversely,
the semantic value of a <i>terminal symbol</i> is an arbitrary value; an
example is <code>CLASS_NAME</code> (the structure of a terminal symbol may be
defined by a regular expression; this is irrelevant as far as the abstract
grammar is concerned). We denote markers in quotes (<code>"abstract"</code>),
and terminal symbols in capitals (<code>CLASS_NAME</code>).  </p>

<p> Each non-terminal symbol <code>a</code> will have a single production in
the grammar.  Instances of <code>a</code> in the AST will be represented by a
class called <code>AST_a</code>.  The attributes of <code>AST_a</code> will
depend on the production for <code>a</code> (see below). </p>

<p> A terminal symbol <code>x</code> will be represented by a class
<code>Token_x</code>. Every token class gets an attribute called
<code>value</code>. The type of this attribute depends on the token; for most
tokens it is <code>String*</code> (this is the default); however, if the
grammar explicitely specifies a type for the value (in angular brackets, for
example <code>REAL&lt;double&gt;</code>), this overrides the default. If the
default value is overridden, the token class gets an additional attribute
<code>source_rep</code>, which corresponds to the value of the token in the
source value. The type of <code>source_rep</code> is always
<code>String*</code>. If the type of the <code>value</code> attribute it set to
be empty, the token class does not get a value but (but it will get a
<code>source_rep</code> field).  </p>

<p> Finally, a marker will not be represented by a specialised class.  Instead,
a marker <code>"foo"</code> may <b>only</b> appear as an optional symbol in a
production rule (<code>a ::= ... "foo"? ...</code>), and will appear as a
boolean attribute <code>is_foo</code> in the class representing <code>a</code>
(<code>AST_a</code>).  </p>

<p>
There are only two types of rules in the grammar. The first is the simplest,
and list a number of alternatives for a non-terminal symbol <code>a</code>:
</p>

<pre>
a ::= b | c | ... | z
</pre>

<p> Here, each of <code>b</code>, <code>c</code>, ..., <code>z</code> must be a
single non-terminal symbol.  This rule results in a (usually) empty <code>class
AST_a {}</code>, which acts as a superclass for the classes for <code>b</code>,
<code>c</code>, ..., <code>z</code>. This reflects the semantics of the rule (a
<code>b</code> <i>is</i> an <code>a</code>); if there are multiple rules
<code>a ::= c|...</code>, <code>b ::= c|...</code>, class <code>AST_c</code>
will inherit from both <code>AST_a</code> and <code>AST_b</code>. This type of
rule is exemplified by the production for <code>statement</code> in the
grammar. There is one additional requirement for disjunction rules, which will
be explained in the section on context resolution, below.  </p>

<p>
The second type is the most common:
</p>

<pre>
a ::= b c ... z
</pre>

<p> In this rule, each of the <code>b</code>, <code>c</code>, ...,
<code>z</code> is an arbitrary symbol (non-terminal, terminal or marker), which
may be optional (<code>b?</code>) or repeated (<code>b*</code> or
<code>b+</code>). This type of rule must not include any disjunctions
(<code>a|b</code>), and only single symbols can be repeated (no grouping). If a
symbol <code>b</code> can be repeated, it will be represented by a specialised
list class <code>AST_list_b</code> (which inherits from the STL
<code>list</code> class) in the tree. In addition, the symbols may be labeled
(<code>label:symbol</code>). This does not add to the grammar structure, but
explains the purpose of the symbol in the rule, and will be used for the name
of the attribute of the corresponding class.  The default name for each class
attribute depends on the corresponding type: an attribute of type
<code>AST_variable_name</code>  (corresponding to a non-terminal
<code>variable_name</code>) will be called <code>variable_name</code>. The
default name for an attribute of type <code>AST_foo_list</code> will be
<i>foos</i>.  However, as mentioned above, this can be overridden by specifying
a label.  </p>

<p> As an example, consider the rule for <code>variable</code> in the grammar.
</p>

<pre>
expr ::= ... | variable | ... ;
variable ::= target? variable_name <i>array_indices</i>:expr?* <i>string_index</i>:expr? ;
</pre>


<p> A <code>variable</code> is an <code>expr</code>, so that
<code>variable</code> is represented by the class shown below. The optionality
of <code>string_index</code> is not reflected directly in the class definition,
but simply means that the <code>string_index</code> field in the class may be
NULL.  </p>

<pre>
<b>class</b> AST_variable : <b>virtual public</b> AST_expr
{
<b>public</b>:
   AST_target* target;
   AST_variable_name* variable_name;
   AST_expr_list* array_indices;
   AST_expr* string_index;
}
</pre>

<p> A final note on combining <code>*</code> and <code>?</code>. The construct
<code>(a*)?</code> denotes an optional list of <code>a</code>s. Thus, it will
be represented by an <code>AST_a_list</code>. If a list is specified,
but empty, the list will simply contain no elements. If the list is not
specified at all, the list will be NULL. This is used, for example, to
distinguish between methods that contain no statements and abstract methods.
Similarly, <code>(a?)*</code> is a (non-optional) list of optional
<code>a</code>s. Thus, this is a list, but elements of the list may be
NULL. This is used for example to denote empty array indices (<code>a[]</code>)
in the rule for <code>variable</code>.  </p>

<h2><a name="contextresolution">Context Resolution</a></h2>

<p> We also derive the tree visitor API and tree transformation API from the
grammar. The tree visitor API is very simple to derive; see the <a
href="generatedcode.html">overview of the generated code</a> for an
explanation. The tree transformation API however is slightly more difficult to
derive. The problem is to decide the signatures for the transform methods, or
in other words, what can transform into what? For example, in the <span
class="phc">phc</span> grammar for PHP, the transform for an if-statement
should be allowed return a list of statements of any kind (because it is
safe to replace an if-statement by a list of statements). Similarly, a binary
operator should be allowed return any other expression (but not a list of
them). For reasons that will become clear very soon, we call the process of
deciding these signatures &ldquo;context resolution&rdquo;. </p>

<h3>Contexts</h3>

<p> A context is essentially a use of a symbol somewhere in a (concrete) rule
in the grammar.  There are four possibilities. Consider: </p>

<pre>
concrete1 ::= ... 
concrete2 ::= ...
concrete3 ::= ...
concrete4 ::= ...
concrete5 ::= ...
concrete6 ::= ...
abstract1 ::= concrete3 | concrete4
abstract2 ::= concrete5 | concrete6
	
some_concrete_rule ::= concrete1 concrete2* abstract1 abstract2* 
</pre>

<p> then, based on the rule for some_concrete_rule, concrete1 occurs in the
context (concrete1,concrete1,Single) - i.e., as a single instance of itself,
concrete2 occurs in the context (concrete2,concrete2,List), i.e.  as a list of
instances of itself. The use of the abstract1 class leads to a number of
contexts: </p>

<pre>
(abstract1,abstract1,Single)
(concrete3,abstract1,Single)
(concrete4,abstract1,Single)
</pre>

<p> And finally, the use of abstract2* yields to the contexts </p>

<pre>
(abstract2,abstract2,List)
(concrete5,abstract2,List)
(concrete6,abstract2,List)
</pre>

<p> These contexts essentially mean that an instance of concrete5 can be
replaced by any number of any (concrete) instance of "abstract2". </p>

<h3>Reducing Contexts</h3>

<p> If there are two or more conflicting contexts for a single symbol, we must
resolve the contexts to their most specific (restrictive) form.  For instance,
for the <span class="phc">phc</span> grammar, this yields </p>

<pre>
(if,statement,List)
(CLASS_NAME,CLASS_NAME,Single)
(INTERFACE_NAME,INTERFACE_NAME,Single)
</pre>

<p>So, a context is a triplet (symbol,symbol,multiplicity), where the symbols
are terminal or non-terminal symbols, and the multiplicity is either Single,
Optional, List, OptionalList or ListOptional (list of optionals).  When
reducing two contexts (<code>a</code>,<code>b</code>,<code>c</code>)
(<code>a'</code>,<code>b'</code>,<code>c'</code>), we take the meet of
<code>b</code> and <code>b'</code> (that is, the most general common subclass
of <code>b</code> and <code>b'</code>, where more general means higher up in
the inheritance hierarchy), and opt for the most restrictive Multiplicity
(Single over Optional, Single over List, etc.). The general idea is that we
want the most permissive context for a non-terminal that is still safe: if it
is safe to replace an <code>a</code> by a list of <code>b</code>s
<i>everywhere</i> in a tree, the context we want for <code>a</code> is
(<code>a</code>, <code>b</code>, list). </p>

<p>To see the reason for taking the meet, consider this fragment of the <span
class="phc">phc</span> grammar:</p>

<pre>
expr ::= ... | BOOL
cast ::= CAST expr
method_invocation ::= target ...
target ::= expr | CLASS_NAME
</pre>

<p>The use of "expr" in the rule for cast leads to the context
(BOOL,expr,Single) The use of "target" in the rule for method_invocation leads
to the context (BOOL,target,Single). By taking the meet of "expr" and "target",
this gives the context (BOOL,expr,Single). This means that it is always safe to
replace a boolean by any other expression (but it is not always safe to replace
a boolean by any other <i>target</i>). </p>
	
<p>In the case of CLASS_NAME, we have the contexts</p>

<pre>
(CLASS_NAME,class_name,Single)
(CLASS_NAME,target,Single)
</pre>

<p>The meet of class_name and target does not exist; hence this gives the
context</p>
	
<pre>
(CLASS_NAME,CLASS_NAME,Single)
</pre>

<p> That is, the only safe transformation for CLASS_NAME is from CLASS_NAME to
CLASS_NAME. </p>

<p>To be precise about the &ldquo;most specific&rdquo; multiplicity, here is a Haskell definition that returns the meet of two multiplicities:</p>

<pre>
meet_mult :: Multiplicity -> Multiplicity -> Multiplicity
meet_mult a b | a == b = a
meet_mult Single _ = Single  
meet_mult List Optional = Single 
meet_mult List OptList = List
meet_mult List ListOpt = List
meet_mult Optional OptList = Single
meet_mult Optional ListOpt = Optional
meet_mult OptList ListOpt = List
meet_mult a b = meet_mult b a  <i>-- meet is commutative</i>
</pre>

<h3>Resolution for Disjunctions</h3>

<p>We cannot deal with this situation:</p>

<pre>
s ::= a
a ::= b | c
d ::= b
e ::= c*
</pre>

<p>This grammar leads to the following contexts:</p>

<pre>
(a,a,Single)
(b,a,Single)
(b,b,Single)
(c,a,Single)
(c,c,List)
</pre>

<p>Resolving these contexts lead to</p>

<pre>
(a,a,Single)
(b,b,Single)
(c,c,List)
</pre>

<p>However, this is incorrect, because this indicates that an <code>a</code>
will only be replaced by another, single, <code>a</code>; but a <code>c</code>
(which is an <code>a</code>) will in fact return a list of <code>c</code>s. The
problem is that the non-terminals in the rule for <code>a</code> have a
different multiplicity in their contexts (single for <code>b</code>, list for
<code>c</code>). <span class="phc">maketea</span> disallows this; if this
happens in a grammar, <span class="phc">maketea</span> will exit with a
&ldquo;cannot deal with mixed multiplicity in disjunction&rdquo; error.</p>

<p>Otherwise, for a rule <code>a ::= b1 | b2 | ...</code>, if the multiplicity
of <code>a</code> is list, and the multiplicities of all the <code>b</code>s
are lists, the multiplicity for <code>a</code> will be list; if the
multiplicity of all the <code>b</code>s is single, the multiplicity for
<code>a</code> will be set to single (independent of the original multiplicity
for <code>a</code>).</p>


		</td></tr>
		<tr>
			<td style="border-top: solid #8a7640 1px; font-size: 8pt; background-color: #efdca5;">
				$LastChangedDate: 2007-01-17 15:55:22 +0000 (Wed, 17 Jan 2007) $. Contents &copy; the <a href="../authors.html">authors</a>.
			</td>
		</tr>
		</table>
	</body>
</html>
