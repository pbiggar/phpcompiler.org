<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>phc -- Representing PHP</title>
		<link rel="stylesheet" type="text/css" href="../phc.css">
	</head>
	<body>
		<table width="796" align="center" cellspacing="0" cellpadding="2" style="border: #8a7640 solid 1px;">
		<tr>
			<td height="149" style="background: url(../img/header.png);">&nbsp;</td>
		</tr>
		<tr>
			<td style="color: white; background-color: #8a7640;">
				<a class="nav" href="../index.html">Home</a> | 
				<a class="nav" href="../src/index.html">Downloads</a> | 
				<a class="nav" href="../doc/index.html">Documentation</a> |
				<a class="nav" href="../plugins/index.html">Plugins</a> |
				<a class="nav" href="../spinoffs/index.html">Spinoff Projects</a> |
				<a class="nav" href="../contact.html">Mailing List</a>
			</td>
		</tr>
		<tr><td style="padding: 5px;">
			<h1>Representing PHP</h1>

			Most PHP constructs can immediately be represented in terms of the
			<span class="phc">phc</span> <a href="grammar.html">abstract
			grammar</a>. There are a few constructs that present some
			difficulties. This document describes how these difficulties are
			resolved, and it explains some of the more difficult rules in the
			grammar.
		
			<h2> <a name="tlgs">Top Level Grammar Structure</a> </h2>

			<i>The</i> major difference between our abstract grammar for PHP and
			the &ldquo;official&rdquo; grammar (distributed in source code format
			with the <a href="http://www.php.net">PHP distribution</a>) is the
			top-level structure. Stripped-down, the top-level of the PHP grammar
			looks something like 

<pre>
php_script ::= statement*

statement ::= class_def | method | if | while | <i>... other statements ...</i>

method ::= statement*

class_def ::= member* 
member ::= method | attribute
</pre>
		
			Compare this to the top-level grammar structure that we have adopted:

<pre>
php_script ::= class_def+

class_def ::= member*
member ::= method | attribute

method ::= statement*

statement ::= if | while | <i>... other statements ...</i>
</pre>
	
			<p> (This shows essentials only; see the <a href="grammar.html">grammar</a> for the details). </p>
			
			<p> This mismatch has two consequences. The first is that PHP allows
			scripts have methods that do not belong to any class, and statements
			that do not belong to any method. <span class="phc">phc</span>
			introduces a special class called <code>%MAIN%</code> for this
			purpose. All functions defined outside the scope of any class get
			added as a static method to <code>%MAIN%</code>, and all statements
			defined outside the scope of any method get added to a special method
			<code>%run%</code> (in <code>%MAIN%</code>). Thus, the following
			simple PHP script</p>
	
<pre>
&lt;?<b>php</b>
   <b>function</b> hello()
   {
      <b>echo</b> "Hello world!";
   }

   hello();
?&gt;
</pre>

			<p>gets represented as</p>

<pre>
&lt;?<b>php</b>
   <b>class</b> %MAIN%
   {
      <b>static function</b> hello()
      {
         <b>%STDLIB%::echo</b>("Hello world!");
      }
   
      <b>static function</b> %run%()
      {
         %MAIN%::hello();
      }
   }
?&gt;
</pre>
	
			<p> The second consequence is that PHP allows scripts to have function
			definitions <i>inside</i> other function definitions (or inside
			<code>if</code>-statements, <code>while</code>-loops, etc.). This is
			not correctly supported by <span class="phc">phc</span>; see <a
			href="../doc/limitations.html">limitations</a>. </p>

			<h2> Method <code>target</code>s </h2>
	
			<p> Recall the grammar rules for method invocations: </p>	

<pre>
method_invocation ::= target method_name actual_parameter* ;
method_name ::= METHOD_NAME | reflection ;
</pre>

			<p> As explained above, <span class="phc">phc</span> thinks of a PHP
			script as consisting of a set of classes. That means that a function
			call must either be invoked on an object, or it must be a static
			method in some class.  The grammar rule for <code>target</code> is
			</p>

<pre>
target ::= expr | CLASS_NAME ;
</pre>

			<p> So, a <code>target</code> is either an expression (for example, in
			<code>$x-&gt;foo()</code>), or a class name (in
			<code>CLASS::foo()</code>). </p>

			<p> When the user does not explicitly specify a target (for example,
			the call to <code>hello()</code> in the example above), <span
			class="phc">phc</span> will automatically insert a target. If the
			method that gets invoked is defined in <code>%MAIN%</code> (i.e., the
			user provided an implementation), the target will be set to
			<code>%MAIN%</code> (for example, the call to <code>hello()</code>).
			Otherwise, the target is set to <code>%STDLIB%</code> (for example,
			the call to <code>echo</code>). Like <code>%MAIN%</code>,
			<code>%STDLIB%</code> is a special class that collects all methods
			defined in the PHP standard library.  (Incidentally, if PHP6
			implements namespaces, namespaces will probably be represented
			similarly.) </p> 
			
			<h2>Variables</h2>
			
			The grammar rule for variables reads

<pre>
variable ::= target? variable_name <i>array_indices:</i>(expr?)* <i>string_index:</i>expr?
variable_name ::= VARIABLE_NAME | reflection 
</pre>

			<p> This is probably one of the more difficult rules in the grammar,
			so it is worth explaining in a bit more detail. The following table
			describe each element of the first rule in detail. </p>
			
			<table>
			<tr>
			<td valign="top"><code>target?</code></td>
			<td>
				Just like function calls, variables can have a target, and just as
				for function calls, this target can be an expression (for an
				object, e.g., <code>$x-&gt;y</code>) or a class name (for a static
				class attribute, e.g. <code>FOO::$y</code>). Unlike function calls
				however, in variables the target is optional (indicated by the
				question mark). If no target is specified, the variable refers to a
				<i>local</i> variable in a method (see <a href="#global">Global
				Variables</a> for information on how we deal with the
				<code>global</code> statement).
			</td>
			</tr>
			<tr>
			<td valign="top"><code>variable_name</code></td>
			<td>
				Again, as for function calls, the name of the variable may be a
				literal <code>VARIABLE_NAME</code> (<code>$x</code>), or be given
				by an expression (which is wrapped up in an
				<code>AST_reflection</code> node). The latter possibility is
				referred to as &ldquo;variable variables&rdquo; in the PHP manual.
				For example, <code>$$x</code> is the variable whose name is
				currently stored in (another) variable called <code>$x</code>.
			</td>
			</tr>
			<tr>
			<td valign="top"><code><i>array_indices:</i>(expr?)*</code></td>
			<td>
				A variable may have one or more array indices, for example
				<code>$x[3][5]</code>. The strange construct <code>(expr?)*</code>
				means: a list of (<code>*</code>) optional (<code>?</code>)
				expressions. For example, <code>$x[4][]</code> is a list of two
				expressions, but the second expression is not given. In PHP, this
				means &ldquo;use the next available index&rdquo;.	
			</td>
			</tr>
			<tr>
			<td valign="top"><code><i>string_index:</i>expr?</code></td>
			<td>
				Finally, a variable may contain one string index (<code>$x{5}</code>)
				that accesses an individual character from a string.
			</td>
			</tr>
			</table>
			
			<p>We illustrate the various possibilities using diagrams:</p> 

			<ul>
			
			<li> The simple case: <code>$x</code> <img
			src="representingphp/variable.png" align="top" alt="tree"> <br> Note
			that the name of the variable is <code>x</code>, not <code>$x</code>
			
			<li> Using a string index: <code>$x{3}</code> <img
			src="representingphp/string_index.png" align="top" alt="tree">
			
			<li> Using array indices: <code>$x[1][][2]</code> <img
			src="representingphp/array_indices.png" align="top" alt="tree"> <br>
			(Note that the empty array index means &ldquo;next available&rdquo; in
			PHP)
			
			<li> Class constants: <code>X::$y</code> <img
			src="representingphp/static_var.png" align="top" alt="tree"> <br> Note
			that here also the variable name is <code>y</code>, not
			<code>$y</code>. The fact that you must write <code>$x-&gt;y</code> but
			<code>X::$y</code> in PHP disappears in the abstract syntax.
			
			<li> Variable variables: <code>$$x</code> <br> <img
			src="representingphp/var_var.png" align="top" alt="tree"> <br> Note how
			the name of the variable (second component) is now given by another
			variable.
			
			<li> Object attributes: <code>$x-&gt;y</code> <br> <img
			src="representingphp/attribute.png" align="top" alt="tree"> <br> Note
			that the target is now given by a variable.
			
			<li> Variable object attributes: <code>$x-&gt;$y</code> <br> <img
			src="representingphp/var_attr.png" align="top" alt="tree"> <br> Both the
			target and the variable name are given by (other) variables.
			
			</ul>
	
			<h2>Comments</h2>

			<p> A number of nodes in the AST are dedicated &ldquo;commented
			nodes&rdquo;. Their corresponding C++ classes inherit from
			<code>AST_commented_node</code>, which introduces a
			<code>List&lt;String*&gt;*</code> attribute called
			<code>comments</code>.  The commented nodes are class members
			(<code>AST_member</code>), statements (<code>AST_statement</code>),
			interface and class definitions (<code>AST_interface_def</code>,
			<code>AST_class_def</code>), switch cases
			(<code>AST_switch_case</code>) and catches (<code>AST_catch</code>).
			</p>

			<p> When the parser encounters a comment in the input, it attaches it
			either to the previous node in the AST, or to the next, according to a
			variable <code>attach_to_previous</code>. This variable is set as
			follows: </p>

			<ul>
			<li> It is reset to <code>false</code> at the start of each line
			<li> It is set to <code>true</code> after seeing a semicolon, or either of the keywords <code>class</code> or <code>function</code>
			</ul>

			<p> Thus, in </p>

<pre>
foo();
<i>// Comment</i>
bar();
</pre>

			<p> the comment gets attached to <code>bar();</code> (to be precise,
			to the corresponding <code>AST_eval_expr</code> node; the function
			call itself is an expression and <span class="phc">phc</span> does
			not associate comments with expressions), but in </p>

<pre>
foo(); <i>// Comment</i>
bar();
</pre>

			<p> the comment gets attached to <code>foo();</code> instead. The same
			applies to multiple comments:	 </p>

<pre>
foo(); <i>/* A */</i> <i>/* B */</i>
<i>// C</i>
<i>// D</i>
bar();
</pre>

			<p> In this snippet, <code>A</code> and <code>B</code> get attached to
			<code>foo();</code>, but <code>C</code> and <code>D</code> get
			attached to <code>bar();</code>. Also, in the following snippet, </p>
			
<pre>
<i>// Comment</i>
echo <i>/* one */</i> 1 + <i>/* two */</i> 2;
</pre>
			
			<p> all comments get attached to the same node.  This should work most
			of the time, if not all the time. In particular, it should never loose
			any comments. If something goes wrong with comments, please <a
			href="../contact.html">send</a> us a sample program that shows where
			it goes wrong. Note that whitespace in multi-line comments gets dealt
			with in a less than satisfactory way; see <a
			href="limitations.html">limitations</a> for details for details. </p> 

			<h2>String parsing</h2>
			
			<p>Double quoted strings and those written using the HEREDOC syntax
			are treated specially by PHP: it parses variables used inside these
			strings and automatically expands them with their value. <span
			class="phc">phc</span> handles both the simple and complex syntax
			defined by PHP for variables in strings. We transform a string like</p>
			
<pre>
"Total cost is: $total (includes shipping of $shipping)"
</pre>
			
			<p>into:</p>

<pre>
"Total cost is: " . $total . " (includes shipping of " . $shipping . ")"
</pre>
			
			<p> which is represented in the <span class="phc">phc</span> abstract
			syntax tree by a number of strings and expressions concatenated
			together. Thus, as a programmer you don't need to do anything special
			to process variables inside strings. Any code you write for processing
			variables will also appropriately handle variables inside strings.
			</p>
			
			<p> Currently, the unparser will <i>not</i> output strings of the
			first form, but will always output them in the second form (using
			concatenation). Future releases of <span class="phc">phc</span> may
			remedy this (alternatively, dedicated more advanced pretty-printing
			tools for PHP could be built on top of <span class="phc">phc</span>;
			see <a href="../spinoffs/index.html">Spinoffs</a>). </p>

			<h2><a name="global">Global Variables</a></h2>

			<p> Global variable declarations are not explicitly recorded in the
			<span class="phc">phc</span> AST. Instead the local variable declared
			global is assigned a reference to the appropriate global variable,
			which will be a static class attribute of %MAIN% (see above
			description of the <a href="#tlgs">Top Level Grammar Structure</a>).
			</p>

			<p> For example, the following code </p>

<pre>
&lt;?<b>php</b>
   $x = 100;

   <b>function</b> foobar()
   {
      <b>global</b> $x;
      $x = 200;
   }
   
   foobar();
?&gt;
</pre>

			<p>is represented internally as</p> 

<pre>
&lt;?php
   <b>class</b> %MAIN%
   {
      <b>static</b> $x = 100;
      
      <b>static</b> <b>function</b> foobar()
      {
         $x =&amp; %MAIN%::$x;
         $x = 200;
      }
   
      <b>static</b> <b>function</b> %run%()
      {
         %MAIN%::foobar();
      }
   }
?&gt;
</pre>

			<p>Obviously, the <span class="phc">phc</span> unparser will output
			code using global declarations.</p>
			
			<p>Note that local variables in <code>%run%</code> are really global
			variables; for that reason, any &ldquo;local&rdquo; variable in
			<code>%run%</code> get assigned a target of <code>%MAIN%</code> (if no
			target was specified in the program). </p>
			
			<h2><code>elseif</code></h2>

			The abstract grammar does not have a construct for <code>elseif</code>.
			The following PHP code

<pre>
&lt;?<b>php</b>
   <b>if</b>($x)
      c1();
   <b>elseif</b>($y)
      c2();
   <b>else</b>
      c3();
?&gt;
</pre>
			gets interpreted as

<pre>
&lt;?<b>php</b>
   <b>if</b>($x)
      c1();
   <b>else</b>
   {
      <b>if</b>($y)
         c2();
      <b>else</b>
         c3();
   }
?&gt;
</pre>

			The higher the number of <code>elseif</code>s, the greater the level
			of nesting. This transformation is &ldquo;hidden&rdquo; by the
			unparser.

			<h2>Miscellaneous Other Changes</h2>

			<ul>
			
			<li>If <code>echo</code> has multiple (comma separated) arguments,
			they get translated into multiple function calls (<code>echo a,
			b;</code> becomes <code>echo a; echo b;</code>). Fragments of inline
			HTML also become arguments to a function call to <code>echo</code>.
			
			<li>The keywords <code>use</code>, <code>require</code>,
			<code>require_once</code>, <code>include</code>,
			<code>include_once</code>, <code>isset</code> and <code>empty</code>
			all get translated into a function call to a function with the same
			name as the keyword
			
			<li><code>exit</code> also becomes a call to the function
			<code>exit</code>; <code>exit;</code> and <code>exit();</code> are
			interpreted as <code>exit(0)</code>
			
			<li>Class attribute declarations can only declare a single attribute
			per declaration in the abstract syntax; thus, <code>var x, y;</code>
			becomes <code>var x; var y;</code>. A similar comment applies to
			<code>static_var</code>
			
			<li>We do not support the <code>+=</code> style of operators; <code>a
			+= 2;</code> gets translated into <code>a = a + 2;</code>. It should
			be possible to reverse this translation in the unparser, but this is
			not currently implemented.
			
			</ul>

			<h2><a name="comparison">Comparison to the PHP grammar</a></h2>

			<p> Finally, the <span class="phc">phc</span> grammar is much simpler than
			the official grammar, and as a consequence more general. The class of
			programs that are valid according to the abstract grammar is larger
			than the class of programs actually accepted by the PHP parser. In
			other words, it is possible to represent a program in the abstract
			syntax that does not have a valid PHP equivalent. The advantage of our
			grammar is that is much, <i>much</i> easier to work with. </p>

			<p> To compare, consider the tree for </p>

<pre>
$g->greet("TACS");
</pre>

			<p> Using the <span class="phc">phc</span> abstract syntax, this
			looks like </p>

			<center><img alt="syntax tree (phc)" src="representingphp/abstract-tree.png"></center>

			<p> However, in the official PHP grammar, the tree would look like </p>

			<center><img alt="syntax tree (PHP)" src="representingphp/concrete-tree.png"></center>

			<p> Not only is the number of concepts used in the tree much larger
			(<code>base_variable_with_function_calls</code>,
			<code>reference_variable</code>, <code>variable_property</code>,
			etc. etc.), the concepts used in the <span class="phc">phc</span>
			tree map directly to constructs in the PHP language; that does not
			hold true for the PHP tree. Moreover, the fact that this expression
			is a method invocation (function call) is immediately obvious from
			the root of the expression in the <span class="phc">phc</span>
			tree; the root of the PHP tree says that the expression is a
			variable, and only deeper down the tree does it become apparent
			that the expression is in fact a function call. </p>

		</td></tr>
		<tr>
			<td style="border-top: solid #8a7640 1px; font-size: 8pt; background-color: #efdca5;">
				$LastChangedDate: 2007-01-17 15:55:22 +0000 (Wed, 17 Jan 2007) $. Contents &copy; the <a href="../authors.html">authors</a>.
			</td>
		</tr>
		</table>
	</body>
</html>
